\documentclass[11pt]{book}
\usepackage[scale=.7]{geometry}
\usepackage{textfit}
\usepackage{relsize}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{ytableau}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{color}
\usepackage{changepage}
\usepackage[colorlinks=true, urlcolor=black, plainpages=false, pdfpagelabels]{hyperref}
\usepackage{etoolbox}
\usepackage{amssymb}
\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{wallpaper}
%\usepackage{tableaux}
\def\specialcolon{\mathrel{\mathop{:}}\hspace{-.5em}}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\algorithm}[2]{{\tt\Large\detokenize{#1}}\\[1ex]
{\emph{#2}}\\[1ex]
}
\newcommand{\property}[2]{{\tt\Large\detokenize{#1}}\\[1ex]
{\emph{#2}}\\[1ex]
}
\newcommand{\algo}[1]{{\tt \detokenize{#1}}}
\newcommand{\prop}[1]{{\tt \detokenize{#1}}}
\renewcommand{\author}[1]{{\bfseries #1}}
\newcommand{\email}[1]{, {\tt #1}}
%\makeatletter\def\old@comma{,}\catcode`\,=13 \def,{%
%\ifmmode\old@comma\discretionary{}{}{}\else\old@comma\fi}\makeatother

% Math expressions wrapped in \brwrap will get typeset with
% round brackets around them, which have the appropriate size.
% The expression itself can still be broken over multiple lines.

\newcommand\brwrap[3]{%
  \setbox0=\hbox{$#2$}
  \left#1\vbox to \the\ht0{\hbox to 0pt{}}\right.\kern-.2em
  \begingroup #2\endgroup\kern-.15em
  \left.\vbox to \the\ht0{\hbox to 0pt{}}\right#3
}

\renewcommand{\arraystretch}{1.2}
\tolerance=10000
\relpenalty=10
\binoppenalty=10
\hyphenpenalty=10
\raggedright

\lstnewenvironment{python}[1][]{\lstset{language=python,
   columns=fullflexible,
   xleftmargin=1em,
   belowskip=0pt,
   tabsize=3,
   commentstyle={}, % otherwise {#} cadabra arguments look ugly
   breaklines=true,   
   basicstyle=\small\ttfamily\color{blue},
   keywordstyle={}
}}{}
  

\everymath{\displaystyle}

% Page numbers
\pagestyle{fancy}
\fancyhf{} % clear all header and footer fields
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyfoot[LE,RO]{{\small\thepage}}
\fancyfoot[LO,RE]{}

% \makeatletter\def\old@comma{,}\catcode`\,=13 \def,{%
% \ifmmode\old@comma\discretionary{}{}{}\else\old@comma\fi}\makeatother

% Ensure that maths broken over multiple lines has a bit of spacing
% between lines.
\lineskiplimit=0mm
\lineskip=1.5ex

% Typesetting Young tableaux, originally in a separate style
% file, now included to avoid path searching problems. 
% Some internals for the typesetting macros below; nothing
% user-servicable here; please read on.

\def\@tabforc#1#2#3{\expandafter\tabf@rc\expandafter#1{#2 \^}{#3}}
\def\tabf@@rc#1#2#3\tabf@@rc#4{\def#1{#2}#4\tabf@rc#1{#3}{#4}}
\long\def\ReturnAfterFi#1\fi{\fi#1}
    \def\tabf@rc#1#2#3{%
      \def\temp@ty{#2}%
      \ifx\@empty\temp@ty
      \else
        \ReturnAfterFi{%
          \tabf@@rc#1#2\tabf@@rc{#3}%
        }%
      \fi
    }%

% Sorry, some global registers for sizes and keeping track of
% measurements.
    
\newdimen\ytsize\ytsize=2mm
\newdimen\ytfsize\ytfsize=4mm
\newcount\repcnt
\newdimen\acchspace
\newdimen\accvspace
\newdimen\raiseh
\newdimen\maxw

\newcommand\phrule[1]{\hbox{\vbox to0pt{\hrule height .2pt width#1\vss}}}

% Typeset a Young tableau with filled boxes. Takes a single 
% argument which is a string of symbols for each row,
% separated by commas. Examples:
%
%   \ftableau{abc,de}
%   \ftableau{ab{d_2},f{g_3}}

\newcommand\ftableau[1]{%
\def\ctest{,}
\def\Ktest{\^}
\acchspace=0ex
\accvspace=0ex
\maxw=0ex
\vbox{\hbox{%
\@tabforc\thisel{#1}{%
 \ifx\thisel\Ktest{%
     \ifnum\maxw=0\maxw=\acchspace\fi%
     \raisebox{\accvspace}{\vbox to \ytfsize{\hbox to
		 0pt{\vrule height \ytfsize\hss}}}\kern\acchspace\kern-\maxw}
 \else\ifx\thisel\ctest
     \ifnum\maxw=0\maxw=\acchspace\fi%
     \raisebox{\accvspace}{\vbox to \ytfsize{\hbox to 0pt{\vrule height \ytfsize\hss}}}%
     \kern\acchspace\acchspace=0ex
	  \advance\accvspace by -\ytfsize
 \else
     \setbox3=\hbox{$\thisel$}%
	  \raiseh=\ytfsize%
	  \advance\raiseh by -1ex%
	  \divide\raiseh by 2%
     \advance\acchspace by-\ytfsize%
     \raisebox{\accvspace}{\vbox to \ytfsize{\hrule\hbox to%
        \ytfsize{\vrule height \ytfsize\hskip.5ex%
         \raisebox{\raiseh}{\tiny$\thisel$}\hss}\vss\phrule{\ytfsize}}}%
 \fi\fi}}}}

% Typeset a Young tableau with unlabelled boxes. Takes a single 
% argument which is a string of numbers, one for the length of
% each row of the tableau. Example:
%
%   \tableau{{10}{8}{3}}
%
% typesets a tableau with 10 boxes in the 1st row, 8 in the 2nd
% and 3 in the 3rd. Curly brackets can be omitted if numbers
% are less than 10.

\newcommand\tableau[1]{%
\def\stest{ }
\def\Ktest{\^}
\acchspace=0ex
\accvspace=0ex
\maxw=0ex
\hbox{%
\@tabforc\thisel{#1}{%
 \ifx\thisel\Ktest{}
 \else
     \repcnt=\thisel%
     \loop{}%
     \advance\acchspace by-\ytsize%
     \raisebox{\accvspace}{\vbox to \ytsize{\hrule \hbox to%
			\ytsize{\vrule height \ytsize\hss}\vss\phrule{\ytsize}}}%
     \advance\repcnt by -1\ifnum\repcnt>1{}\repeat%
     \ifnum\maxw=0\maxw=\acchspace\fi%
     \raisebox{\accvspace}{\vbox to \ytsize{\hbox to 0pt{\vrule height \ytsize\hss}}}%
     \kern\acchspace\acchspace=0ex%
	  \advance\accvspace by -\ytsize%
 \fi}\kern-\maxw}}
 
\ytableausetup{centertableaux} % smalltableaux

\begin{document}
\pagestyle{empty}
\ThisLRCornerWallPaper{1.0}{book_cover}
\begin{flushright}
\today
\end{flushright}
\vspace{6ex}
{\bf \scaletowidth{15cm}{The Cadabra Book}}~\\[.8ex] 
{\it\large A field-theory motivated approach to symbolic computer algebra}\\[6ex]
{\bf \scaletowidth{5cm}{Kasper Peeters}}
\newpage
\pagestyle{empty}
\hbox{~}
\noindent {\smaller This book is available under the terms of the GNU Free
Documentation License, version 1.2.\\
The accompanying software is available under the terms of the GNU
General Public License, version 3.}
\vfill
\noindent {\large\bf Copyright \copyright~2001-2020 ~Kasper Peeters}\\[3ex]
\href{mailto:kasper.peeters@cadabra.science}{kasper.peeters@cadabra.science}

\pagestyle{fancy} 
\tableofcontents

\chapter{Introduction and overview}
\section{Cadabra's design philosophy}

Cadabra is built around the fact that many computations do not have
one single and unique path between the starting point and the end
result. When we do computations on paper, we often take bits of an
expression apart, do some manipulations on them, stick them back into
the main expression, and so on. Often, the manipulations that we do
are far from uniquely determined by the problem, and often there is no
way even in principle for a computer to figure out what is 'the best'
thing to do.

What we need the computer to do, in such a case, is to be good at
performing simple but tedious steps, without enforcing on the user how
to do a particular computation. In other words, we want the computer
algebra system to be a scratchpad, leaving us in control of which
steps to take, not forcing us to return to a 'canonical' expression at
every stage.

Most existing computer algebra systems allow for this kind of work
flow only by requiring to stick clumsy 'inert' or 'hold' arguments
onto expressions, by default always 'simplifying' every input to some
form they think is best. Cadabra starts from the other end of the
spectrum, and as a general rule keeps your expression untouched,
unless you explicitly ask for something to be done to it.

Another key issue in the design of symbolic computer algebra systems
has always been whether or not there should be a distinction between
the 'data language' (the language used to write down mathematical
expressions), the 'manipulation language' (the language used to write
down what you want to do with those expressions) and the
'implementation language' (the language used to implement algorithms
which act on mathematical expressions). Many computer algebra systems
take the approach in which these languages are the same (Axiom,
Reduce, Sympy) or mostly the same apart from a small core which uses a
different implementation language (Mathematica, Maple). The Cadabra
project is rooted in the idea that for many applications, it is better
to keep a clean distinction between these three languages. Cadabra
writes mathematics using LaTeX, is programmable in Python, and is
under the hood largely written in C++.

\section{History}

Cadabra was originally written around 2001 to solve <a
href="https://arxiv.org/abs/hep-th/0010167">a number</a> <a
href="https://arxiv.org/abs/hep-th/0307298">of problems</a> related to
higher-derivative supergravity. It was then expanded and polished, and
first saw its public release <a
href="https://arxiv.org/abs/hep-th/0701238">in 2007</a>.  During the
years that followed, it became clear that several design decisions
were not ideal, such as the use of a custom programming language and
the lack of functionality for component computations. Over the course
of 2015-2016 a large rewrite took place, which resulted in Cadabra
2.x.  This new version is programmable in Python and does both
abstract and component computations. This new web site, with new
tutorials and all manual pages accessible online, will also hopefully
help to make Cadabra easier to use.


\chapter{The input format}
\input{input_format.tex}
\input{ref_printing.tex}
\input{ref_properties.tex}
\input{ref_indices.tex}
\input{ref_implicit_versus_explicit.tex}

\chapter{Mathematical properties}
\input{ref_derivatives.tex}

\chapter{Manipulating expressions}
\input{ref_selecting.tex}
\input{ref_import.tex}
\input{ref_default_simplification}
\input{ref_patterns}

\chapter{Writing your own packages}
\input{ref_programming}

\end{document}

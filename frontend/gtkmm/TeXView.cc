
#include "TeXView.hh"
#include <iostream>
#include <cairo/cairo.h>
#include <cairomm/context.h>
#include <giomm/resource.h>
#include <gdkmm/general.h> // set_source_pixbuf()
#include <regex>

#ifdef USE_MICROTEX
  #include "platform/cairo/graphic_cairo.h"
#endif

using namespace cadabra;

TeXView::TeXView(TeXEngine& eng, DTree::iterator it, int hmargin)
	: content(0), datacell(it), vbox(false, 10), hbox(false, hmargin), engine(eng)
	{
	// Still need to checkin even when using MicroTeX, otherwise
	// all requests will be empty.
	content = engine.checkin(datacell->textbuf, "", "");
	
#if GTKMM_MINOR_VERSION>=10
	add(rbox);
	rbox.add(vbox);
	rbox.set_reveal_child(false);
	rbox.set_transition_duration(1000);
	rbox.set_transition_type(Gtk::REVEALER_TRANSITION_TYPE_CROSSFADE); //SLIDE_DOWN);
#else
	add(vbox);
#endif
	vbox.set_margin_top(10);
	vbox.set_margin_bottom(0);
	vbox.pack_start(hbox, true, 0);
	hbox.pack_start(image, true, hmargin);
	//	 add(image);
	add_events( Gdk::BUTTON_PRESS_MASK | Gdk::BUTTON_RELEASE_MASK );
	}

TeXView::~TeXView()
	{
	engine.checkout(content);
	}

void TeXView::on_show()
	{
	convert();
	Gtk::EventBox::on_show();
	}

bool TeXView::TeXArea::on_configure_event(GdkEventConfigure *cfg)
	 {
	 bool ret = Gtk::DrawingArea::on_configure_event(cfg);

	 rendering_width = cfg->width;

	 std::cerr << "**** configure width " << cfg->width << std::endl;

	 return ret;
	 }

void TeXView::convert()
	{
	std::cerr << "*** convert called" << std::endl;
#ifdef USE_MICROTEX
	try {
		// Ensure that all TeX cells have been rendered by TeX. This will do nothing
		// if no TeX cells need (re-)rendering. When adding many cells in one go, do so
		// in hidden state. Then, at first show, the first cell will trigger the
		// convert_all and run TeX on all cells in one shot.

		engine.convert_all();

		// Set the Pixbuf to the image generated by engine.
		// The `content` variable is the TeXRequest.
		image.update_image(content, engine.get_scale());
		}
	catch(TeXEngine::TeXException& ex) {
		tex_error.emit(ex.what());
		}
#else
	image.update_image(content, engine.get_scale());
#endif
	}


void TeXView::dim(bool d)
	{
	if(d) image.set_opacity(0.3);
	else  image.set_opacity(1.0);
	}

bool TeXView::on_button_release_event(GdkEventButton *)
	{
	show_hide_requested.emit(datacell);
	return true;
	}

void TeXView::update_image()
	{
	image.update_image(content, engine.get_scale());
	}

void TeXView::TeXArea::update_image(std::shared_ptr<TeXEngine::TeXRequest> content, double scale)
	{
#ifdef USE_MICROTEX
	if(content) 
		set_latex(content->latex());
#else
	if(content->image().size()==0)
		return;
	
	if(content->image().data()==0)
		return;
	

	pixbuf =
	   Gdk::Pixbuf::create_from_data(content->image().data(), Gdk::COLORSPACE_RGB,
	                                 true,
	                                 8,
	                                 content->width(), content->height(),
	                                 4*content->width());

	if(pixbuf)
		set_size_request(pixbuf->get_width(), pixbuf->get_height());

	//	update=true;
	scale_=scale;
	// HERE
	//	image.set(pixbuf);
#endif
	}


bool TeXView::TeXArea::on_draw(const Cairo::RefPtr<Cairo::Context>& cr)
	{
#ifdef USE_MICROTEX

	std::cerr << "*** rendering at size " << get_width() << " x " << get_height() << std::endl;
	cr->set_source_rgb(1, 1, 1);
	cr->rectangle(0, 0, get_width(), get_height());
	cr->fill();
	if (_render == nullptr) return true;
	tex::Graphics2D_cairo g2(cr);
	_render->draw(g2, _padding, _padding);
	return true;

#else

	if(!pixbuf) return false;

	//	Gtk::Allocation allocation = get_allocation();
	//	const int width = allocation.get_width();
	//	const int height = allocation.get_height();
	auto surface = cr->get_target();
	auto csurface = surface->cobj();
	//	cairo_surface_set_device_scale(csurface, 1.0, 1.0);
	//	cairo_surface_mark_dirty(csurface);
	double device_scale_x, device_scale_y;
	cairo_surface_get_device_scale(csurface, &device_scale_x, &device_scale_y);
	//	std::cerr << device_scale_x << std::endl;
	set_size_request(pixbuf->get_width()/device_scale_x, pixbuf->get_height()/device_scale_y+1);
	cr->scale(1.0/device_scale_x, 1.0/device_scale_y);
	Gdk::Cairo::set_source_pixbuf(cr, pixbuf, 0, 0);
	cr->paint();
	cr->scale(1.0, 1.0);

	return true;
#endif
	}

#ifdef USE_MICROTEX
void TeXView::TeXArea::check_invalidate()
	{
	if (_render == nullptr) return;
	
	int parent_width = get_parent()->get_width();
	int parent_height = get_parent()->get_height();
	int target_width = parent_width;
	int target_height = parent_height;
	
	int extra = (int) (_padding * 2);
	if (parent_width < _render->getWidth() + extra) {
      target_width = _render->getWidth() + extra;
		}
	if (parent_height < _render->getHeight() + extra) {
      target_height = _render->getHeight() + extra;
		}

	std::cerr << "*** adjust size request " << target_width << " x " << target_height <<
		" in parent " << parent_width << " x " << parent_height << std::endl;
	set_size_request(target_width, target_height);
	
	auto win = get_window();
	if (win) {
      auto al = get_allocation();
      Gdk::Rectangle r(0, 0, al.get_width(), al.get_height());
      win->invalidate_rect(r, false);
		}
	}

void TeXView::TeXArea::set_latex(const std::string& latex)
	{
	if(_render)
		delete _render;

	std::cout << "rendering " << latex << std::endl;

	std::string fixed;
	if(latex.find(R"(\begin{dmath*})")==0) {
		// math mode
		std::regex begin_dmath(R"(\\begin\{dmath\*\})");
		std::regex end_dmath(R"(\\end\{dmath\*\})");
		fixed = std::regex_replace(latex, begin_dmath, "");
		fixed = std::regex_replace(fixed, end_dmath, "");
		}
	else {
		// text mode
		fixed = "\\text{"+latex+"}";
		}

	std::cout << "*** rendering fixed " << fixed << " at width " << rendering_width << std::endl;
	
	_render = tex::LaTeX::parse(
      tex::utf82wide(fixed),
		rendering_width,
//      get_allocated_width() - _padding * 2,
      _text_size,
      _text_size / 3.f,
      0xff424242
								  );
	
	check_invalidate();
	}

// bool TeXView::TeXArea::isRenderDisplayed()
// 	{
// 	return _render != nullptr;
// 	}

// int TeXView::TeXArea::getRenderWidth()
// 	{
// 	return _render == nullptr ? 0 : _render->getWidth() + _padding * 2;
// 	}
// 
// int TeXView::TeXArea::getRenderHeight()
// 	{
// 	return _render == nullptr ? 0 : _render->getHeight() + _padding * 2;
// 	}

// void TeXView::TeXArea::drawInContext(const Cairo::RefPtr<Cairo::Context>& cr)
// 	{
// 	if (_render == nullptr) return;
// 	Graphics2D_cairo g2(cr);
// 	_render->draw(g2, _padding, _padding);
// 	}

#endif

TeXView::TeXArea::TeXArea()
	: rendering_width(1)
#ifdef USE_MICROTEX
	, _render(nullptr), _text_size(30.f), _padding(10)
#endif
	{
	}

TeXView::TeXArea::~TeXArea()
	{
#ifdef USE_MICROTEX
	if(_render)
		delete _render;
#endif
	}

